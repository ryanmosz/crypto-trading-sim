<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Cleanup Utility</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%231a1a1a'/><text x='8' y='11' font-family='monospace' font-size='12' font-weight='bold' text-anchor='middle' fill='%23ff0000'>X</text></svg>" type="image/svg+xml">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1, h2 {
            color: #ff6666;
            font-family: 'Arial Black', sans-serif;
        }
        .warning {
            background: #660000;
            border: 2px solid #ff0000;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .section {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        button {
            background: #ff3333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
        }
        button:hover {
            background: #cc0000;
        }
        button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        .safe-button {
            background: #00cc00;
        }
        .safe-button:hover {
            background: #009900;
        }
        #output {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .stat-card {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
        }
        .confirm-checkbox {
            margin: 10px 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>üóëÔ∏è Database Cleanup Utility</h1>
    
    <div class="warning">
        <h2>‚ö†Ô∏è WARNING: DESTRUCTIVE OPERATIONS</h2>
        <p>This utility will permanently delete data from the database. Use with caution!</p>
        <p>It's recommended to backup your database before running any cleanup operations.</p>
    </div>

    <div class="section">
        <h2>üìä Current Database Stats</h2>
        <button class="safe-button" onclick="loadStats()">Refresh Stats</button>
        <div class="stats" id="stats">
            <div class="stat-card">
                <div>Active Games</div>
                <div class="stat-number" id="stat-active-games">-</div>
            </div>
            <div class="stat-card">
                <div>Game Participants</div>
                <div class="stat-number" id="stat-participants">-</div>
            </div>
            <div class="stat-card">
                <div>Price History Records</div>
                <div class="stat-number" id="stat-price-history">-</div>
            </div>
            <div class="stat-card">
                <div>Cached Prices</div>
                <div class="stat-number" id="stat-prices">-</div>
            </div>
            <div class="stat-card">
                <div>Total Users</div>
                <div class="stat-number" id="stat-users">-</div>
            </div>
            <div class="stat-card">
                <div>Completed Games</div>
                <div class="stat-number" id="stat-completed">-</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>üßπ Selective Cleanup</h2>
        <p>Remove specific types of data:</p>
        
        <h3>Old/Invalid Games</h3>
        <button onclick="findOldGames()">Find Games with Invalid Schema</button>
        <button onclick="cleanupOldGames()">Delete Invalid Games</button>
        
        <h3>Expired Games</h3>
        <button onclick="findExpiredGames()">Find Expired Games</button>
        <button onclick="cleanupExpiredGames()">Delete Expired Games</button>
        
        <h3>Price Data</h3>
        <button onclick="findExtraCryptos()">Find Non-Game Cryptos</button>
        <button onclick="cleanupExtraCryptos()">Remove Extra Cryptos</button>
        <button onclick="cleanupOldPriceHistory()">Clean Old Price History (>30 days)</button>
        <button onclick="deepCleanPriceHistory()">Deep Clean ALL Price History</button>
        
        <h3>Orphaned Data</h3>
        <button onclick="findOrphanedParticipants()">Find Orphaned Participants</button>
        <button onclick="cleanupOrphans()">Clean Orphaned Records</button>
    </div>

    <div class="section">
        <h2>üî• Nuclear Options</h2>
        <p>Complete data reset (preserves user accounts):</p>
        
        <div class="confirm-checkbox">
            <label>
                <input type="checkbox" id="confirmDelete" onchange="toggleNuclearButtons()">
                I understand this will DELETE ALL GAME DATA
            </label>
        </div>
        
        <button id="deleteAllGames" onclick="deleteAllGames()" disabled>Delete ALL Games</button>
        <button id="deleteAllParticipants" onclick="deleteAllParticipants()" disabled>Delete ALL Participants</button>
        <button id="deleteAllPriceHistory" onclick="deleteAllPriceHistory()" disabled>Delete ALL Price History</button>
        <button id="fullReset" onclick="fullGameReset()" disabled style="background: #ff0000;">
            FULL GAME RESET (All of the above)
        </button>
    </div>

    <div class="section">
        <h2>üìù Output Log</h2>
        <div id="output">Database Cleanup Utility Ready
Use with caution - these operations cannot be undone!</div>
    </div>

    <!-- Load dependencies -->
    <script src="config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script>
        let supabaseClient;
        const GAME_CRYPTOS = ['BTC', 'ETH', 'BNB', 'SOL', 'XRP'];
        
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toISOString();
            const typeSymbol = {
                'error': '‚ùå',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'info': '‚ÑπÔ∏è'
            }[type] || '';
            
            output.textContent += `\n${timestamp} ${typeSymbol} - ${message}`;
            output.scrollTop = output.scrollHeight;
        }
        
        // Initialize Supabase
        async function initializeSupabase() {
            try {
                const { createClient } = supabase;
                supabaseClient = createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
                
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (user) {
                    log(`Authenticated as: ${user.email}`, 'success');
                    loadStats();
                } else {
                    log('Not authenticated - please login first', 'error');
                }
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error');
            }
        }
        
        // Load database stats
        async function loadStats() {
            log('Loading database statistics...', 'info');
            
            try {
                // Active games
                const { count: activeGames } = await supabaseClient
                    .from('active_games')
                    .select('*', { count: 'exact', head: true })
                    .eq('is_complete', false);
                document.getElementById('stat-active-games').textContent = activeGames || 0;
                
                // Completed games
                const { count: completedGames } = await supabaseClient
                    .from('active_games')
                    .select('*', { count: 'exact', head: true })
                    .eq('is_complete', true);
                document.getElementById('stat-completed').textContent = completedGames || 0;
                
                // Participants
                const { count: participants } = await supabaseClient
                    .from('game_participants')
                    .select('*', { count: 'exact', head: true });
                document.getElementById('stat-participants').textContent = participants || 0;
                
                // Price history
                const { count: priceHistory } = await supabaseClient
                    .from('price_history')
                    .select('*', { count: 'exact', head: true });
                document.getElementById('stat-price-history').textContent = priceHistory || 0;
                
                // Cached prices
                const { data: prices } = await supabaseClient
                    .from('prices_cache')
                    .select('symbol');
                document.getElementById('stat-prices').textContent = prices?.length || 0;
                
                // Users
                const { count: users } = await supabaseClient
                    .from('profiles')
                    .select('*', { count: 'exact', head: true });
                document.getElementById('stat-users').textContent = users || 0;
                
                log('Stats loaded successfully', 'success');
            } catch (error) {
                log(`Error loading stats: ${error.message}`, 'error');
            }
        }
        
        // Find games with old/invalid schema
        async function findOldGames() {
            log('Finding games with invalid schema...', 'info');
            
            try {
                const { data: games } = await supabaseClient
                    .from('active_games')
                    .select('id, game_code, created_at');
                    
                let invalidGames = 0;
                for (const game of games || []) {
                    // Check for games without game_code (old schema)
                    if (!game.game_code) {
                        invalidGames++;
                        log(`Found invalid game: ${game.id} (no game code)`, 'warning');
                    }
                }
                
                log(`Found ${invalidGames} games with invalid schema`, invalidGames > 0 ? 'warning' : 'success');
            } catch (error) {
                log(`Error finding old games: ${error.message}`, 'error');
            }
        }
        
        // Clean up old games
        async function cleanupOldGames() {
            log('Cleaning up games with invalid schema...', 'warning');
            
            try {
                // Delete games without game_code
                const { error } = await supabaseClient
                    .from('active_games')
                    .delete()
                    .is('game_code', null);
                    
                if (error) throw error;
                
                log('Invalid games cleaned up', 'success');
                loadStats();
            } catch (error) {
                log(`Error cleaning old games: ${error.message}`, 'error');
            }
        }
        
        // Find extra cryptos
        async function findExtraCryptos() {
            log('Finding non-game cryptocurrencies...', 'info');
            
            try {
                const { data: prices } = await supabaseClient
                    .from('prices_cache')
                    .select('symbol, price');
                    
                const extraCryptos = prices?.filter(p => !GAME_CRYPTOS.includes(p.symbol)) || [];
                
                if (extraCryptos.length > 0) {
                    log(`Found ${extraCryptos.length} extra cryptocurrencies:`, 'warning');
                    extraCryptos.forEach(c => log(`  - ${c.symbol}: $${c.price}`, 'info'));
                } else {
                    log('No extra cryptocurrencies found', 'success');
                }
            } catch (error) {
                log(`Error finding extra cryptos: ${error.message}`, 'error');
            }
        }
        
        // Clean up extra cryptos
        async function cleanupExtraCryptos() {
            log('Removing non-game cryptocurrencies...', 'warning');
            
            try {
                const { error } = await supabaseClient
                    .from('prices_cache')
                    .delete()
                    .not('symbol', 'in', `(${GAME_CRYPTOS.join(',')})`);
                    
                if (error) throw error;
                
                log('Extra cryptocurrencies removed', 'success');
                loadStats();
            } catch (error) {
                log(`Error cleaning cryptos: ${error.message}`, 'error');
            }
        }
        
        // Find expired games
        async function findExpiredGames() {
            log('Finding expired games...', 'info');
            
            try {
                const { data: games } = await supabaseClient
                    .from('active_games')
                    .select('id, game_code, ends_at, is_complete')
                    .lt('ends_at', new Date().toISOString())
                    .eq('is_complete', false);
                    
                if (games && games.length > 0) {
                    log(`Found ${games.length} expired but not completed games:`, 'warning');
                    games.forEach(g => log(`  - ${g.game_code || 'No code'}: ended ${g.ends_at}`, 'info'));
                } else {
                    log('No expired games found', 'success');
                }
            } catch (error) {
                log(`Error finding expired games: ${error.message}`, 'error');
            }
        }
        
        // Find orphaned participants
        async function findOrphanedParticipants() {
            log('Finding orphaned participants...', 'info');
            
            try {
                // Get all participants
                const { data: participants } = await supabaseClient
                    .from('game_participants')
                    .select('id, game_id');
                    
                // Get all game IDs
                const { data: games } = await supabaseClient
                    .from('active_games')
                    .select('id');
                    
                const gameIds = new Set(games?.map(g => g.id) || []);
                const orphaned = participants?.filter(p => !gameIds.has(p.game_id)) || [];
                
                if (orphaned.length > 0) {
                    log(`Found ${orphaned.length} orphaned participants`, 'warning');
                } else {
                    log('No orphaned participants found', 'success');
                }
            } catch (error) {
                log(`Error finding orphans: ${error.message}`, 'error');
            }
        }
        
        // Clean orphaned records
        async function cleanupOrphans() {
            log('Cleaning orphaned records...', 'warning');
            
            try {
                // Get all game IDs
                const { data: games } = await supabaseClient
                    .from('active_games')
                    .select('id');
                    
                const gameIds = games?.map(g => g.id) || [];
                
                if (gameIds.length === 0) {
                    log('No games found, skipping orphan cleanup', 'info');
                    return;
                }
                
                // Delete participants not in any game
                const { error: participantError } = await supabaseClient
                    .from('game_participants')
                    .delete()
                    .not('game_id', 'in', `(${gameIds.join(',')})`);
                    
                if (participantError) {
                    log(`Error cleaning participants: ${participantError.message}`, 'error');
                } else {
                    log('Orphaned participants cleaned', 'success');
                }
                
                // Delete price history not in any game
                const { error: priceError } = await supabaseClient
                    .from('price_history')
                    .delete()
                    .not('game_id', 'in', `(${gameIds.join(',')})`);
                    
                if (priceError) {
                    log(`Error cleaning price history: ${priceError.message}`, 'error');
                } else {
                    log('Orphaned price history cleaned', 'success');
                }
                
                loadStats();
            } catch (error) {
                log(`Error cleaning orphans: ${error.message}`, 'error');
            }
        }
        
        // Clean old price history
        async function cleanupOldPriceHistory() {
            log('Cleaning price history older than 30 days...', 'warning');
            
            try {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                
                const { error } = await supabaseClient
                    .from('price_history')
                    .delete()
                    .lt('recorded_at', thirtyDaysAgo.toISOString());
                    
                if (error) {
                    log(`Error cleaning old price history: ${error.message}`, 'error');
                } else {
                    log('Old price history cleaned', 'success');
                    loadStats();
                }
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }
        
        // Clean up expired games
        async function cleanupExpiredGames() {
            log('Cleaning up expired games...', 'warning');
            
            try {
                // First mark expired games as complete
                const { error: updateError } = await supabaseClient
                    .from('active_games')
                    .update({ is_complete: true })
                    .lt('ends_at', new Date().toISOString())
                    .eq('is_complete', false);
                    
                if (updateError) {
                    log(`Error marking games complete: ${updateError.message}`, 'error');
                } else {
                    log('Expired games marked as complete', 'success');
                    loadStats();
                }
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }

        // Toggle nuclear buttons
        function toggleNuclearButtons() {
            const confirmed = document.getElementById('confirmDelete').checked;
            document.getElementById('deleteAllGames').disabled = !confirmed;
            document.getElementById('deleteAllParticipants').disabled = !confirmed;
            document.getElementById('deleteAllPriceHistory').disabled = !confirmed;
            document.getElementById('fullReset').disabled = !confirmed;
        }
        
        // Nuclear options
        async function deleteAllGames() {
            if (!confirm('Are you SURE you want to delete ALL games?')) return;
            
            log('DELETING ALL GAMES...', 'error');
            try {
                const { error } = await supabaseClient
                    .from('active_games')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
                    
                if (error) throw error;
                log('All games deleted', 'success');
                loadStats();
            } catch (error) {
                log(`Error deleting games: ${error.message}`, 'error');
            }
        }
        
        async function deleteAllParticipants() {
            if (!confirm('Are you SURE you want to delete ALL participants?')) return;
            
            log('DELETING ALL PARTICIPANTS...', 'error');
            try {
                const { error } = await supabaseClient
                    .from('game_participants')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
                    
                if (error) throw error;
                log('All participants deleted', 'success');
                loadStats();
            } catch (error) {
                log(`Error deleting participants: ${error.message}`, 'error');
            }
        }
        
        async function deleteAllPriceHistory() {
            if (!confirm('Are you SURE you want to delete ALL price history?')) return;
            
            log('DELETING ALL PRICE HISTORY...', 'error');
            try {
                const { error } = await supabaseClient
                    .from('price_history')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
                    
                if (error) throw error;
                log('All price history deleted', 'success');
                loadStats();
            } catch (error) {
                log(`Error deleting price history: ${error.message}`, 'error');
            }
        }
        
        async function fullGameReset() {
            if (!confirm('This will DELETE ALL GAME DATA. Are you absolutely sure?')) return;
            if (!confirm('FINAL WARNING: This cannot be undone. Continue?')) return;
            
            log('PERFORMING FULL GAME RESET...', 'error');
            
            try {
                // Delete in order to respect foreign keys
                // First, delete ALL price history
                log('Step 1: Deleting all price history...', 'info');
                const { error: priceError } = await supabaseClient
                    .from('price_history')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                if (priceError) {
                    log(`Price history error: ${priceError.message}`, 'error');
                } else {
                    log('Price history deleted', 'success');
                }
                
                // Second, delete all participants
                log('Step 2: Deleting all participants...', 'info');
                const { error: participantError } = await supabaseClient
                    .from('game_participants')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                if (participantError) {
                    log(`Participant error: ${participantError.message}`, 'error');
                } else {
                    log('Participants deleted', 'success');
                }
                
                // Wait a moment to ensure deletions are processed
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Check if any price history remains
                const { count: remainingPriceHistory } = await supabaseClient
                    .from('price_history')
                    .select('*', { count: 'exact', head: true });
                    
                if (remainingPriceHistory > 0) {
                    log(`Warning: ${remainingPriceHistory} price history records remain`, 'warning');
                    // Try to delete them again
                    const { error: retryError } = await supabaseClient
                        .from('price_history')
                        .delete()
                        .neq('id', '00000000-0000-0000-0000-000000000000');
                    if (retryError) {
                        log(`Retry error: ${retryError.message}`, 'error');
                    }
                }
                
                // Finally, delete all games
                log('Step 3: Deleting all games...', 'info');
                const { error: gamesError } = await supabaseClient
                    .from('active_games')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                if (gamesError) {
                    log(`Games error: ${gamesError.message}`, 'error');
                    log('Tip: Try running individual cleanup operations first', 'warning');
                    return;
                } else {
                    log('All games deleted', 'success');
                }
                
                log('FULL RESET COMPLETE', 'success');
                log('User accounts preserved', 'info');
                log('Ready for fresh start!', 'success');
                
                // Reload stats after reset
                loadStats();
            } catch (error) {
                log(`Error during reset: ${error.message}`, 'error');
            }
        }
        
        // Add a more thorough cleanup function
        async function deepCleanPriceHistory() {
            log('Performing deep clean of price history...', 'warning');
            
            try {
                // First, get all price history records
                const { data: records, error: fetchError } = await supabaseClient
                    .from('price_history')
                    .select('id');
                    
                if (fetchError) {
                    log(`Error fetching records: ${fetchError.message}`, 'error');
                    return;
                }
                
                log(`Found ${records?.length || 0} price history records`, 'info');
                
                // Delete in batches
                if (records && records.length > 0) {
                    const batchSize = 100;
                    for (let i = 0; i < records.length; i += batchSize) {
                        const batch = records.slice(i, i + batchSize);
                        const ids = batch.map(r => r.id);
                        
                        const { error } = await supabaseClient
                            .from('price_history')
                            .delete()
                            .in('id', ids);
                            
                        if (error) {
                            log(`Batch delete error: ${error.message}`, 'error');
                        } else {
                            log(`Deleted batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(records.length/batchSize)}`, 'info');
                        }
                    }
                }
                
                log('Deep clean complete', 'success');
                loadStats();
            } catch (error) {
                log(`Deep clean error: ${error.message}`, 'error');
            }
        }
        
        // Initialize on load
        window.addEventListener('load', initializeSupabase);
    </script>
</body>
</html> 